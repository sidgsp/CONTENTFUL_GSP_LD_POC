{"ast":null,"code":"import F, { useRef, useEffect, useState, useCallback, useMemo } from 'react';\nimport { useId, mergeRefs, useControllableState } from '@contentful/f36-core';\nimport { Popover } from '@contentful/f36-popover';\nimport { cx, css } from 'emotion';\nimport b from '@contentful/f36-tokens';\nimport { Caption } from '@contentful/f36-typography';\nimport { ChevronRightIcon } from '@contentful/f36-icons';\nvar Fe = Object.defineProperty,\n  We = Object.defineProperties;\nvar Be = Object.getOwnPropertyDescriptors;\nvar W = Object.getOwnPropertySymbols;\nvar me = Object.prototype.hasOwnProperty,\n  ae = Object.prototype.propertyIsEnumerable;\nvar ue = (e, t, o) => t in e ? Fe(e, t, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: o\n  }) : e[t] = o,\n  u = (e, t) => {\n    for (var o in t || (t = {})) me.call(t, o) && ue(e, o, t[o]);\n    if (W) for (var o of W(t)) ae.call(t, o) && ue(e, o, t[o]);\n    return e;\n  },\n  C = (e, t) => We(e, Be(t));\nvar x = (e, t) => {\n  var o = {};\n  for (var n in e) me.call(e, n) && t.indexOf(n) < 0 && (o[n] = e[n]);\n  if (e != null && W) for (var n of W(e)) t.indexOf(n) < 0 && ae.call(e, n) && (o[n] = e[n]);\n  return o;\n};\nvar ce = {\n    vertical: {\n      prev: \"ArrowUp\",\n      next: \"ArrowDown\"\n    },\n    horizontal: {\n      prev: \"ArrowLeft\",\n      next: \"ArrowRight\"\n    }\n  },\n  pe = _ref => {\n    let {\n      itemsContainerRef: e,\n      itemsSelector: t,\n      keyType: o = \"vertical\"\n    } = _ref;\n    let [n, s] = useState(0),\n      a = useCallback(i => {\n        let l = e.current;\n        if (!l) return;\n        let T = l.querySelectorAll(t);\n        if (T.length === 0) return;\n        let c = T.length - 1,\n          S = () => s(0),\n          g = () => s(c),\n          f = () => {\n            n === c ? S() : s(n + 1);\n          },\n          h = () => {\n            n === 0 ? g() : s(n - 1);\n          },\n          y = {\n            [ce[o].next]: f,\n            [ce[o].prev]: h\n          }[i.key];\n        y && (i.preventDefault(), y());\n      }, [n, t, e, o]);\n    return {\n      focusedIndex: n,\n      handleArrowsKeyDown: a,\n      setFocusedIndex: s\n    };\n  };\nvar fe = F.createContext(void 0),\n  O = () => {\n    let e = F.useContext(fe);\n    if (e === void 0) throw new Error(\"useMenuContext must be used within a MenuContextProvider\");\n    return e;\n  },\n  de = fe.Provider;\nvar z = '[role=\"menuitem\"]:not(:disabled)';\nfunction B(e) {\n  let oe = e,\n    {\n      closeOnSelect: t = !0,\n      closeOnBlur: o = !0,\n      closeOnEsc: n = !0,\n      children: s,\n      onOpen: a\n    } = oe,\n    i = x(oe, [\"closeOnSelect\", \"closeOnBlur\", \"closeOnEsc\", \"children\", \"onOpen\"]),\n    {\n      isOpen: l,\n      handleOpen: T,\n      handleClose: c,\n      isControlled: S\n    } = useControllableState({\n      isOpen: e.isOpen,\n      defaultIsOpen: e.defaultIsOpen,\n      onOpen: a,\n      onClose: e.onClose\n    }),\n    g = useRef(null),\n    f = useRef(null),\n    h = useId(null, \"menu\"),\n    {\n      focusedIndex: M,\n      handleArrowsKeyDown: y,\n      setFocusedIndex: m\n    } = pe({\n      itemsContainerRef: f,\n      itemsSelector: z\n    });\n  useEffect(() => {\n    if (l && f.current) {\n      let r = f.current.querySelectorAll(z);\n      r.length > 0 && M < r.length && setTimeout(() => {\n        r[M].focus({\n          preventScroll: !1\n        });\n      }, 0);\n    }\n  }, [l, M]);\n  let I = useCallback(r => {\n      let d = [...f.current.querySelectorAll(z)].findIndex(P => r === P);\n      d !== -1 && m(d);\n    }, [m]),\n    p = useCallback(() => {\n      var r;\n      c(), (r = g.current) == null || r.focus({\n        preventScroll: !0\n      });\n    }, [c]),\n    E = useCallback(r => {\n      if (r.key === \"Tab\") {\n        r.preventDefault(), p();\n        return;\n      }\n      if (r.stopPropagation(), r.key === \"ArrowLeft\") {\n        r.preventDefault(), p();\n        return;\n      }\n      y(r);\n    }, [p, y]),\n    K = useRef(!1),\n    De = useMemo(() => ({\n      isOpen: l,\n      menuId: h,\n      focusMenuItem: I,\n      getTriggerProps: function () {\n        let r = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        let w = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n        return {\n          onMouseDown: d => {\n            var P;\n            K.current = !0, (P = r.onMouseDown) == null || P.call(r, d);\n          },\n          onMouseUp: d => {\n            var P;\n            K.current = !1, (P = r.onMouseUp) == null || P.call(r, d);\n          },\n          onClick: d => {\n            var v;\n            S && !a || (l ? c() : T()), (v = r.onClick) == null || v.call(r, d);\n          },\n          ref: mergeRefs(g, w)\n        };\n      },\n      getMenuListProps: function () {\n        let r = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        let w = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n        return {\n          ref: mergeRefs(f, w),\n          onKeyDown: d => {\n            var P;\n            E(d), (P = r.onKeyDown) == null || P.call(r, d);\n          },\n          onBlur: d => {\n            var ne, re, se, ie;\n            if ((ne = r.onBlur) == null || ne.call(r, d), !o) return;\n            let P = document.activeElement,\n              v = d.relatedTarget || P,\n              He = f.current === v || ((re = f.current) == null ? void 0 : re.contains(v)),\n              Ne = g.current === v || ((se = g.current) == null ? void 0 : se.contains(v)) || K.current,\n              Ae = ((ie = v == null ? void 0 : v.parentElement) == null ? void 0 : ie.dataset.parentMenu) === h;\n            if (He || Ne || Ae) {\n              d.stopPropagation();\n              return;\n            }\n            c();\n          }\n        };\n      },\n      getMenuItemProps: function () {\n        let r = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        return {\n          onClick: w => {\n            var P;\n            (P = r.onClick) == null || P.call(r, w);\n            let d = !!w.target.getAttribute(\"aria-haspopup\");\n            t && !d && p();\n          }\n        };\n      },\n      propsToPropagateToSubmenus: {\n        closeOnSelect: t,\n        closeOnBlur: o,\n        closeOnEsc: n\n      }\n    }), [h, l, E, t, c, T, I, o, n, p, S, a]);\n  return F.createElement(de, {\n    value: De\n  }, F.createElement(Popover, C(u({}, i), {\n    isOpen: l,\n    onClose: c,\n    id: h,\n    closeOnEsc: n,\n    autoFocus: !1,\n    closeOnBlur: !1\n  }), s));\n}\nvar Pe = F.createContext(void 0),\n  U = () => F.useContext(Pe),\n  xe = Pe.Provider;\nvar be = () => css({\n    position: \"sticky\",\n    top: 0,\n    left: 0,\n    backgroundColor: b.colorWhite,\n    borderBottom: \"1px solid \".concat(b.gray300),\n    marginBottom: b.spacing2Xs,\n    padding: \"\".concat(b.spacing2Xs, \" 0\"),\n    zIndex: 1001\n  }),\n  Te = () => css({\n    position: \"sticky\",\n    bottom: 0,\n    left: 0,\n    backgroundColor: b.colorWhite,\n    borderTop: \"1px solid \".concat(b.gray300),\n    marginTop: b.spacing2Xs,\n    padding: \"\".concat(b.spacing2Xs, \" 0\"),\n    zIndex: 1001\n  }),\n  he = e => ({\n    container: css({\n      borderRadius: \"8px\",\n      overflowY: \"auto\",\n      position: \"relative\",\n      padding: 0,\n      paddingTop: e.hasStickyHeader ? 0 : b.spacing2Xs,\n      paddingBottom: e.hasStickyFooter ? 0 : b.spacing2Xs\n    })\n  });\nvar k = e => {\n  let i = e,\n    {\n      children: t,\n      testId: o = \"cf-ui-menu-list-header\",\n      className: n\n    } = i,\n    s = x(i, [\"children\", \"testId\", \"className\"]),\n    a = be();\n  return F.createElement(\"div\", u({\n    \"data-test-id\": o,\n    className: cx(a, n)\n  }, s), t);\n};\nk.displayName = \"MenuListHeader\";\nvar D = e => {\n  let i = e,\n    {\n      children: t,\n      testId: o = \"cf-ui-menu-list-footer\",\n      className: n\n    } = i,\n    s = x(i, [\"children\", \"testId\", \"className\"]),\n    a = Te();\n  return F.createElement(\"div\", u({\n    \"data-test-id\": o,\n    className: cx(a, n)\n  }, s), t);\n};\nD.displayName = \"MenuListFooter\";\nfunction _e(e) {\n  var t;\n  return !!((t = e == null ? void 0 : e.type) != null && t.displayName);\n}\nvar et = (e, t) => {\n    let h = e,\n      {\n        children: o,\n        testId: n = \"cf-ui-menu-list\",\n        className: s\n      } = h,\n      a = x(h, [\"children\", \"testId\", \"className\"]),\n      {\n        getMenuListProps: i\n      } = O(),\n      l = U(),\n      T = null,\n      c = null,\n      S = [];\n    F.Children.forEach(o, M => {\n      let y = !0;\n      _e(M) && (M.type.displayName === k.displayName ? (T = M, y = !1) : M.type.displayName === D.displayName && (c = M, y = !1)), y && S.push(M);\n    });\n    let g = he({\n        hasStickyHeader: !!T,\n        hasStickyFooter: !!c\n      }),\n      f = l ? l.getSubmenuListProps(a) : a;\n    return F.createElement(Popover.Content, C(u(u({\n      role: \"menu\"\n    }, f), i(f, t)), {\n      className: cx(g.container, s),\n      testId: n\n    }), T, S, c);\n  },\n  q = F.forwardRef(et);\nvar ot = {\n    backgroundColor: b.gray200,\n    fontWeight: b.fontWeightMedium,\n    \"&:hover\": {\n      backgroundColor: b.gray200\n    }\n  },\n  Se = {\n    opacity: .5,\n    cursor: \"auto\",\n    \"&:hover\": {\n      backgroundColor: \"unset\"\n    }\n  },\n  Ce = _ref2 => {\n    let {\n      isActive: e,\n      isDisabled: t\n    } = _ref2;\n    return {\n      root: css([{\n        alignItems: \"center\",\n        gap: b.spacingXs,\n        display: \"flex\",\n        width: \"calc(100% - 2 * \".concat(b.spacing2Xs, \")\"),\n        background: \"none\",\n        border: 0,\n        borderRadius: b.borderRadiusMedium,\n        margin: \"0 \".concat(b.spacing2Xs),\n        outline: \"none\",\n        fontSize: b.fontSizeM,\n        lineHeight: b.lineHeightM,\n        fontWeight: b.fontWeightNormal,\n        position: \"relative\",\n        textAlign: \"left\",\n        padding: \"6px \".concat(b.spacingXs),\n        wordBreak: \"break-word\",\n        whiteSpace: \"break-spaces\",\n        cursor: \"pointer\",\n        hyphens: \"auto\",\n        minWidth: \"150px\",\n        textDecoration: \"none\",\n        color: b.gray900,\n        '[role=\"menuitem\"] + &': {\n          marginTop: \"2px\"\n        },\n        \"&:hover\": {\n          backgroundColor: b.gray100\n        },\n        \"&:focus\": {\n          boxShadow: \"inset \".concat(b.glowPrimary)\n        },\n        \"&:focus:not(:focus-visible)\": {\n          boxShadow: \"unset\"\n        },\n        \"&:focus-visible\": {\n          boxShadow: \"inset \".concat(b.glowPrimary)\n        },\n        \"&:active\": {\n          backgroundColor: b.gray200\n        },\n        \"&:disabled\": Se\n      }], e && ot, t && Se)\n    };\n  };\nvar mt = \"button\";\nfunction Ee(e, t) {\n  let I = e,\n    {\n      testId: o,\n      className: n,\n      as: s,\n      isActive: a = !1,\n      isDisabled: i = !1,\n      isInitiallyFocused: l,\n      icon: T\n    } = I,\n    c = x(I, [\"testId\", \"className\", \"as\", \"isActive\", \"isDisabled\", \"isInitiallyFocused\", \"icon\"]),\n    S = useId(void 0, \"menu-item\"),\n    g = o || \"cf-ui-\".concat(S),\n    f = Ce({\n      isActive: a,\n      isDisabled: i\n    }),\n    {\n      getMenuItemProps: h,\n      focusMenuItem: M\n    } = O(),\n    y = useRef(null);\n  useEffect(() => {\n    l && y.current && M(y.current);\n  }, [l, M]);\n  let m = s != null ? s : mt;\n  return F.createElement(m, C(u(u({\n    role: \"menuitem\"\n  }, c), h(c)), {\n    className: cx(f.root, n),\n    \"data-test-id\": g,\n    ref: mergeRefs(y, t),\n    tabIndex: -1\n  }), T, e.children);\n}\nEe.displayName = \"MenuItem\";\nvar H = F.forwardRef(Ee);\nvar N = e => {\n  let t = F.Children.only(e.children),\n    {\n      getTriggerProps: o\n    } = O();\n  return F.createElement(Popover.Trigger, null, F.cloneElement(t, C(u({}, o(t.props, t.ref)), {\n    \"aria-haspopup\": \"menu\"\n  })));\n};\nvar Le = () => css({\n  border: \"none\",\n  width: \"100%\",\n  height: \"1px\",\n  backgroundColor: b.gray200,\n  margin: \"\".concat(b.spacing2Xs, \" 0\")\n});\nvar V = e => {\n  let i = e,\n    {\n      children: t,\n      testId: o = \"cf-ui-menu-divider\",\n      className: n\n    } = i,\n    s = x(i, [\"children\", \"testId\", \"className\"]),\n    a = Le();\n  return F.createElement(\"hr\", u({\n    \"aria-orientation\": \"horizontal\",\n    \"data-test-id\": o,\n    className: cx(a, n)\n  }, s));\n};\nvar Re = () => css({\n  color: b.gray500,\n  textAlign: \"left\",\n  padding: \"\".concat(b.spacingXs, \" \").concat(b.spacingS, \" \").concat(b.spacing2Xs),\n  lineHeight: b.lineHeightM\n});\nvar J = e => {\n  let i = e,\n    {\n      children: t,\n      testId: o = \"cf-ui-menu-section-title\",\n      className: n\n    } = i,\n    s = x(i, [\"children\", \"testId\", \"className\"]),\n    a = Re();\n  return F.createElement(Caption, u({\n    \"aria-hidden\": \"true\",\n    as: \"div\",\n    testId: o,\n    className: cx(a, n),\n    marginBottom: \"none\"\n  }, s), t);\n};\nvar Tt = [-8, 2],\n  Z = e => {\n    let y = e,\n      {\n        onClose: t,\n        onOpen: o\n      } = y,\n      n = x(y, [\"onClose\", \"onOpen\"]),\n      {\n        isOpen: s,\n        menuId: a,\n        propsToPropagateToSubmenus: i\n      } = O(),\n      l = useRef(null),\n      T = useRef(null),\n      [c, S] = useState(!1),\n      g = useCallback(() => {\n        S(!0), window.clearTimeout(T.current), o == null || o();\n      }, [o]),\n      f = useCallback(() => {\n        S(!1), window.clearTimeout(T.current), t == null || t();\n      }, [t]),\n      h = useCallback(() => {\n        var m;\n        f(), (m = l.current) == null || m.focus({\n          preventScroll: !0\n        });\n      }, [f]);\n    useEffect(() => {\n      s === !1 && S(!1);\n    }, [s]);\n    let M = useMemo(() => ({\n      isOpen: c,\n      getSubmenuListProps: m => ({\n        \"data-parent-menu\": a,\n        onMouseOver: I => {\n          var p;\n          g(), (p = m.onMouseOver) == null || p.call(m, I);\n        },\n        onMouseLeave: I => {\n          var p;\n          h(), (p = m.onMouseLeave) == null || p.call(m, I);\n        }\n      }),\n      getSubmenuTriggerProps: (m, I) => ({\n        ref: mergeRefs(l, I),\n        onKeyDown: p => {\n          var E;\n          p.key === \"ArrowRight\" && (p.preventDefault(), g()), (E = m.onKeyDown) == null || E.call(m, p);\n        },\n        onMouseOver: p => {\n          var E;\n          g(), (E = m.onMouseOver) == null || E.call(m, p);\n        },\n        onMouseLeave: p => {\n          var E;\n          T.current = window.setTimeout(h, 300), (E = m.onMouseLeave) == null || E.call(m, p);\n        }\n      })\n    }), [c, a, g, h]);\n    return F.createElement(xe, {\n      value: M\n    }, F.createElement(B, C(u(u({}, i), n), {\n      isOpen: c,\n      onClose: f,\n      onOpen: g,\n      placement: \"right-start\",\n      offset: Tt,\n      isAutoalignmentEnabled: !1\n    })));\n  };\nvar ke = () => ({\n  root: _ref3 => {\n    let {\n      isActive: e\n    } = _ref3;\n    return css(u({\n      display: \"flex\",\n      alignItems: \"center\",\n      paddingRight: b.spacingXs\n    }, e ? {\n      backgroundColor: b.gray100\n    } : {}));\n  },\n  content: css({\n    marginRight: b.spacingM\n  }),\n  icon: css({\n    marginLeft: \"auto\",\n    fill: \"currentColor\"\n  })\n});\nvar Ct = (e, t) => {\n    let {\n        className: o,\n        children: n\n      } = e,\n      {\n        getSubmenuTriggerProps: s,\n        isOpen: a\n      } = U(),\n      i = ke();\n    return F.createElement(N, null, F.createElement(H, C(u(u({}, e), s(e, t)), {\n      className: cx(i.root({\n        isActive: a\n      }), o)\n    }), F.createElement(\"span\", {\n      className: i.content\n    }, n), F.createElement(ChevronRightIcon, {\n      className: i.icon\n    })));\n  },\n  te = F.forwardRef(Ct);\nvar R = B;\nR.List = q;\nR.ListHeader = k;\nR.ListFooter = D;\nR.Item = H;\nR.Trigger = N;\nR.Divider = V;\nR.SectionTitle = J;\nR.Submenu = Z;\nR.SubmenuTrigger = te;\nexport { R as Menu, V as MenuDivider, H as MenuItem, q as MenuList, J as MenuSectionTitle, N as MenuTrigger, Z as Submenu, te as SubmenuTrigger };\n//# sourceMappingURL=out.js.map","map":{"version":3,"names":[],"sources":["C:\\Users\\Siddharth Ganti\\Desktop\\GSP_LD_POC\\price-custom-app\\node_modules\\@contentful\\f36-menu\\src\\Menu.tsx","C:\\Users\\Siddharth Ganti\\Desktop\\GSP_LD_POC\\price-custom-app\\node_modules\\@contentful\\f36-menu\\src\\useArrowKeyNavigation.ts","C:\\Users\\Siddharth Ganti\\Desktop\\GSP_LD_POC\\price-custom-app\\node_modules\\@contentful\\f36-menu\\src\\MenuContext.ts","C:\\Users\\Siddharth Ganti\\Desktop\\GSP_LD_POC\\price-custom-app\\node_modules\\@contentful\\f36-menu\\src\\MenuList\\MenuList.tsx","C:\\Users\\Siddharth Ganti\\Desktop\\GSP_LD_POC\\price-custom-app\\node_modules\\@contentful\\f36-menu\\src\\SubmenuContext.ts","C:\\Users\\Siddharth Ganti\\Desktop\\GSP_LD_POC\\price-custom-app\\node_modules\\@contentful\\f36-menu\\src\\MenuList\\MenuList.styles.ts","C:\\Users\\Siddharth Ganti\\Desktop\\GSP_LD_POC\\price-custom-app\\node_modules\\@contentful\\f36-menu\\src\\MenuList\\MenuListHeader.tsx","C:\\Users\\Siddharth Ganti\\Desktop\\GSP_LD_POC\\price-custom-app\\node_modules\\@contentful\\f36-menu\\src\\MenuList\\MenuListFooter.tsx","C:\\Users\\Siddharth Ganti\\Desktop\\GSP_LD_POC\\price-custom-app\\node_modules\\@contentful\\f36-menu\\src\\MenuItem\\MenuItem.tsx","C:\\Users\\Siddharth Ganti\\Desktop\\GSP_LD_POC\\price-custom-app\\node_modules\\@contentful\\f36-menu\\src\\MenuItem\\MenuItem.styles.ts","C:\\Users\\Siddharth Ganti\\Desktop\\GSP_LD_POC\\price-custom-app\\node_modules\\@contentful\\f36-menu\\src\\MenuTrigger\\MenuTrigger.tsx","C:\\Users\\Siddharth Ganti\\Desktop\\GSP_LD_POC\\price-custom-app\\node_modules\\@contentful\\f36-menu\\src\\MenuDivider\\MenuDivider.tsx","C:\\Users\\Siddharth Ganti\\Desktop\\GSP_LD_POC\\price-custom-app\\node_modules\\@contentful\\f36-menu\\src\\MenuDivider\\MenuDivider.styles.ts","C:\\Users\\Siddharth Ganti\\Desktop\\GSP_LD_POC\\price-custom-app\\node_modules\\@contentful\\f36-menu\\src\\MenuSectionTitle\\MenuSectionTitle.tsx","C:\\Users\\Siddharth Ganti\\Desktop\\GSP_LD_POC\\price-custom-app\\node_modules\\@contentful\\f36-menu\\src\\MenuSectionTitle\\MenuSectionTitle.styles.ts","C:\\Users\\Siddharth Ganti\\Desktop\\GSP_LD_POC\\price-custom-app\\node_modules\\@contentful\\f36-menu\\src\\Submenu\\Submenu.tsx","C:\\Users\\Siddharth Ganti\\Desktop\\GSP_LD_POC\\price-custom-app\\node_modules\\@contentful\\f36-menu\\src\\SubmenuTrigger\\SubmenuTrigger.tsx","C:\\Users\\Siddharth Ganti\\Desktop\\GSP_LD_POC\\price-custom-app\\node_modules\\@contentful\\f36-menu\\src\\SubmenuTrigger\\SubmenuTrigger.styles.ts","C:\\Users\\Siddharth Ganti\\Desktop\\GSP_LD_POC\\price-custom-app\\node_modules\\@contentful\\f36-menu\\src\\CompoundMenu.tsx"],"sourcesContent":["import React, { useCallback, useMemo, useRef, useEffect } from 'react';\nimport { mergeRefs, useId, useControllableState } from '@contentful/f36-core';\nimport { Popover, type PopoverProps } from '@contentful/f36-popover';\n\nimport { useArrowKeyNavigation } from './useArrowKeyNavigation';\nimport { MenuContextProvider, MenuContextType } from './MenuContext';\n\nconst MENU_ITEMS_SELECTOR = '[role=\"menuitem\"]:not(:disabled)';\n\nexport interface MenuProps\n  extends Omit<PopoverProps, 'autoFocus' | 'id' | 'closeOnBlur'> {\n  /**\n   * By default, the Menu is uncontrolled (manage it's expanded state by itself)\n   * But you can make it controlled by providing boolean (true/false)\n   */\n  isOpen?: boolean;\n\n  /**\n   * If `true`, the Menu will be initially opened.\n   */\n  defaultIsOpen?: boolean;\n\n  /**\n   * Callback fired when the Menu opens\n   */\n  onOpen?: () => void;\n\n  /**\n   * Callback fired when the Menu closes\n   */\n  onClose?: () => void;\n\n  /**\n   * If `true`, the Menu will close when a menu item is\n   * clicked\n   *\n   * Note: This prop will be propagated to all submenus,\n   * unless you will override it with props on submenu itself\n   *\n   * @default true\n   */\n  closeOnSelect?: boolean;\n\n  /**\n   * If true, the menu will close when you blur out it by clicking outside\n   *\n   * Note: This prop will be propagated to all submenus,\n   * unless you will override it with props on submenu itself\n   *\n   * @default true\n   */\n  closeOnBlur?: boolean;\n\n  /**\n   * If true, the menu will close when you hit the Esc key\n   *\n   * Note: This prop will be propagated to all submenus,\n   * unless you will override it with props on submenu itself\n   *\n   * @default true\n   */\n  closeOnEsc?: boolean;\n}\n\nexport function Menu(props: MenuProps) {\n  const {\n    closeOnSelect = true,\n    closeOnBlur = true,\n    closeOnEsc = true,\n    children,\n    onOpen,\n    ...otherProps\n  } = props;\n  const { isOpen, handleOpen, handleClose, isControlled } =\n    useControllableState({\n      isOpen: props.isOpen,\n      defaultIsOpen: props.defaultIsOpen,\n      onOpen,\n      onClose: props.onClose,\n    });\n\n  const triggerRef = useRef<HTMLButtonElement>(null);\n  const menuListRef = useRef<HTMLDivElement>(null);\n\n  const menuId = useId(null, 'menu');\n\n  const { focusedIndex, handleArrowsKeyDown, setFocusedIndex } =\n    useArrowKeyNavigation({\n      itemsContainerRef: menuListRef,\n      itemsSelector: MENU_ITEMS_SELECTOR,\n    });\n\n  useEffect(() => {\n    if (isOpen && menuListRef.current) {\n      const menuItems =\n        menuListRef.current.querySelectorAll(MENU_ITEMS_SELECTOR);\n\n      if (menuItems.length > 0 && focusedIndex < menuItems.length) {\n        // timeout trick to prevent scroll from jumping\n        // when the popover is not positioned correctly yet in the opening phase\n        setTimeout(() => {\n          (menuItems[focusedIndex] as HTMLElement).focus({\n            preventScroll: false,\n          });\n        }, 0);\n      }\n    }\n  }, [isOpen, focusedIndex]);\n\n  const focusMenuItem = useCallback(\n    (item: HTMLElement) => {\n      const menuItems =\n        menuListRef.current.querySelectorAll(MENU_ITEMS_SELECTOR);\n\n      const itemIndex = [...menuItems].findIndex(\n        (menuItem) => item === menuItem,\n      );\n\n      if (itemIndex !== -1) {\n        setFocusedIndex(itemIndex);\n      }\n    },\n    [setFocusedIndex],\n  );\n\n  const closeAndFocusTrigger = useCallback(() => {\n    handleClose();\n    triggerRef.current?.focus({ preventScroll: true });\n  }, [handleClose]);\n\n  const handleMenuListKeyDown = useCallback(\n    (event: React.KeyboardEvent) => {\n      if (event.key === 'Tab') {\n        event.preventDefault();\n        closeAndFocusTrigger();\n        return;\n      }\n\n      // we don't want to propagate other keydown events except `Tab`\n      event.stopPropagation();\n\n      if (event.key === 'ArrowLeft') {\n        event.preventDefault();\n        closeAndFocusTrigger();\n        return;\n      }\n\n      handleArrowsKeyDown(event);\n    },\n    [closeAndFocusTrigger, handleArrowsKeyDown],\n  );\n\n  // Safari has an issue with the relatedTarget that we use on the onBlur for menuListProps,\n  // which was causing the menu to close and reopen when clicking on the trigger.\n  // We will use the isMouseDown to prevent triggering blur in the cases where the user clicks on the trigger.\n  const isMouseDown = useRef<Boolean>(false);\n\n  const contextValue: MenuContextType = useMemo(\n    () => ({\n      isOpen,\n      menuId,\n      focusMenuItem,\n      getTriggerProps: (_props = {}, _ref = null) => ({\n        onMouseDown: (event) => {\n          isMouseDown.current = true;\n          _props.onMouseDown?.(event);\n        },\n        onMouseUp: (event) => {\n          isMouseDown.current = false;\n          _props.onMouseUp?.(event);\n        },\n        onClick: (event) => {\n          // if the user made component controlled by providing isOpen prop\n          // but onOpen callback is not provided, we won't add toggle logic\n          // to the trigger component. So they can make any toggle logic on their own.\n          const isFullyControlled = isControlled && !onOpen;\n\n          if (!isFullyControlled) {\n            if (isOpen) {\n              handleClose();\n            } else {\n              handleOpen();\n            }\n          }\n\n          _props.onClick?.(event);\n        },\n        ref: mergeRefs(triggerRef, _ref),\n      }),\n      getMenuListProps: (_props = {}, _ref = null) => ({\n        ref: mergeRefs(menuListRef, _ref),\n        onKeyDown: (event) => {\n          handleMenuListKeyDown(event);\n          _props.onKeyDown?.(event);\n        },\n        onBlur: (event) => {\n          _props.onBlur?.(event);\n\n          if (!closeOnBlur) {\n            return;\n          }\n\n          const activeElement = document.activeElement;\n          const relatedTarget = event.relatedTarget || activeElement;\n\n          const targetIsMenu =\n            menuListRef.current === relatedTarget ||\n            menuListRef.current?.contains(relatedTarget);\n          const targetIsTrigger =\n            triggerRef.current === relatedTarget ||\n            triggerRef.current?.contains(relatedTarget) ||\n            isMouseDown.current;\n          const targetIsSubmenu =\n            relatedTarget?.parentElement?.dataset.parentMenu === menuId;\n\n          if (targetIsMenu || targetIsTrigger || targetIsSubmenu) {\n            event.stopPropagation();\n            return;\n          }\n\n          handleClose();\n        },\n      }),\n      getMenuItemProps: (_props = {}) => ({\n        onClick: (event) => {\n          _props.onClick?.(event);\n\n          const isSubmenuTrigger = Boolean(\n            (event.target as HTMLElement).getAttribute('aria-haspopup'),\n          );\n          if (closeOnSelect && !isSubmenuTrigger) {\n            closeAndFocusTrigger();\n          }\n        },\n      }),\n      propsToPropagateToSubmenus: {\n        closeOnSelect,\n        closeOnBlur,\n        closeOnEsc,\n      },\n    }),\n    [\n      menuId,\n      isOpen,\n      handleMenuListKeyDown,\n      closeOnSelect,\n      handleClose,\n      handleOpen,\n      focusMenuItem,\n      closeOnBlur,\n      closeOnEsc,\n      closeAndFocusTrigger,\n      isControlled,\n      onOpen,\n    ],\n  );\n\n  return (\n    <MenuContextProvider value={contextValue}>\n      <Popover\n        {...otherProps}\n        isOpen={isOpen}\n        onClose={handleClose}\n        id={menuId}\n        closeOnEsc={closeOnEsc}\n        // eslint-disable-next-line jsx-a11y/no-autofocus\n        autoFocus={false}\n        closeOnBlur={false}\n      >\n        {children}\n      </Popover>\n    </MenuContextProvider>\n  );\n}\n","import { useState, useCallback } from 'react';\n\ninterface UseArrowKeyNavigationProps {\n  itemsContainerRef: React.MutableRefObject<HTMLElement>;\n  itemsSelector: string;\n  keyType?: 'vertical' | 'horizontal';\n  initialFocusedIndex?: number;\n}\n\nconst ARROW_KEY_TYPES = {\n  vertical: {\n    prev: 'ArrowUp',\n    next: 'ArrowDown',\n  },\n  horizontal: {\n    prev: 'ArrowLeft',\n    next: 'ArrowRight',\n  },\n};\n\nexport const useArrowKeyNavigation = ({\n  itemsContainerRef,\n  itemsSelector,\n  keyType = 'vertical',\n}: UseArrowKeyNavigationProps) => {\n  const [focusedIndex, setFocusedIndex] = useState<number>(0);\n\n  const handleArrowsKeyDown = useCallback(\n    (event: React.KeyboardEvent) => {\n      const container = itemsContainerRef.current;\n      if (!container) return;\n\n      const items = container.querySelectorAll(itemsSelector);\n      if (items.length === 0) return;\n\n      const lastItemIndex = items.length - 1;\n\n      const focusFirstItem = () => setFocusedIndex(0);\n      const focusLastItem = () => setFocusedIndex(lastItemIndex);\n      const focusNextItem = () => {\n        if (focusedIndex === lastItemIndex) {\n          focusFirstItem();\n        } else {\n          setFocusedIndex(focusedIndex + 1);\n        }\n      };\n      const focusPrevItem = () => {\n        if (focusedIndex === 0) {\n          focusLastItem();\n        } else {\n          setFocusedIndex(focusedIndex - 1);\n        }\n      };\n\n      const keyToFnMap = {\n        [ARROW_KEY_TYPES[keyType].next]: focusNextItem,\n        [ARROW_KEY_TYPES[keyType].prev]: focusPrevItem,\n      };\n\n      const fn = keyToFnMap[event.key];\n      if (fn) {\n        event.preventDefault();\n        fn();\n      }\n    },\n    [focusedIndex, itemsSelector, itemsContainerRef, keyType],\n  );\n\n  return { focusedIndex, handleArrowsKeyDown, setFocusedIndex };\n};\n","import React, { ComponentPropsWithRef } from 'react';\nimport { MenuProps } from '.';\n\nexport type MenuContextType = {\n  isOpen: boolean;\n  menuId: string;\n  focusMenuItem: (item: HTMLElement) => void;\n  getTriggerProps: (\n    _props: ComponentPropsWithRef<'button'>,\n    _ref: React.Ref<HTMLButtonElement>,\n  ) => ComponentPropsWithRef<'button'>;\n  getMenuListProps: (\n    _props: ComponentPropsWithRef<'div'>,\n    _ref: React.Ref<HTMLDivElement>,\n  ) => ComponentPropsWithRef<'div'>;\n  getMenuItemProps: (\n    _props: ComponentPropsWithRef<'button'>,\n  ) => ComponentPropsWithRef<'button'>;\n  propsToPropagateToSubmenus: Pick<\n    MenuProps,\n    'closeOnBlur' | 'closeOnEsc' | 'closeOnSelect'\n  >;\n};\n\nconst MenuContext = React.createContext<MenuContextType | undefined>(undefined);\n\nexport const useMenuContext = () => {\n  const context = React.useContext(MenuContext);\n\n  if (context === undefined) {\n    throw new Error('useMenuContext must be used within a MenuContextProvider');\n  }\n\n  return context;\n};\n\nexport const MenuContextProvider = MenuContext.Provider;\n","import React from 'react';\nimport type {\n  CommonProps,\n  PropsWithHTMLElement,\n  ExpandProps,\n} from '@contentful/f36-core';\nimport { useMenuContext } from '../MenuContext';\nimport { useSubmenuContext } from '../SubmenuContext';\nimport { Popover } from '@contentful/f36-popover';\nimport { cx } from 'emotion';\nimport { getMenuListStyles } from './MenuList.styles';\nimport { MenuListHeader } from './MenuListHeader';\nimport { MenuListFooter } from './MenuListFooter';\n\ninterface MenuListInternalProps extends CommonProps {\n  children?: React.ReactNode;\n}\n\nfunction assertChild(child: any): child is { type: { displayName: string } } {\n  return Boolean(child?.type?.displayName);\n}\n\nexport type MenuListProps = PropsWithHTMLElement<MenuListInternalProps, 'div'>;\n\nconst _MenuList = (\n  props: ExpandProps<MenuListProps>,\n  ref: React.Ref<HTMLDivElement>,\n) => {\n  const {\n    children,\n    testId = 'cf-ui-menu-list',\n    className,\n    ...otherProps\n  } = props;\n\n  const { getMenuListProps } = useMenuContext();\n  const submenuContext = useSubmenuContext();\n\n  let header: React.ReactElement | null = null;\n  let footer: React.ReactElement | null = null;\n  const items: React.ReactElement[] = [];\n\n  React.Children.forEach(children, (child) => {\n    let appendChild = true;\n    if (assertChild(child)) {\n      if (child.type.displayName === MenuListHeader.displayName) {\n        header = child as unknown as React.ReactElement;\n        appendChild = false;\n      } else if (child.type.displayName === MenuListFooter.displayName) {\n        footer = child as unknown as React.ReactElement;\n        appendChild = false;\n      }\n    }\n    if (appendChild) {\n      items.push(child as unknown as React.ReactElement);\n    }\n  });\n\n  const styles = getMenuListStyles({\n    hasStickyHeader: Boolean(header),\n    hasStickyFooter: Boolean(footer),\n  });\n\n  const extendedOtherProps = submenuContext\n    ? submenuContext.getSubmenuListProps(otherProps)\n    : otherProps;\n\n  return (\n    <Popover.Content\n      role=\"menu\"\n      {...extendedOtherProps}\n      {...getMenuListProps(extendedOtherProps, ref)}\n      className={cx(styles.container, className)}\n      testId={testId}\n    >\n      {header}\n      {items}\n      {footer}\n    </Popover.Content>\n  );\n};\n\nexport const MenuList = React.forwardRef(_MenuList);\n","import React, { ComponentPropsWithRef, ComponentPropsWithoutRef } from 'react';\n\nexport type SubmenuContextType = {\n  isOpen: boolean;\n  getSubmenuListProps: (\n    _props: ComponentPropsWithRef<'div'>,\n  ) => { 'data-parent-menu': string } & ComponentPropsWithoutRef<'div'>;\n  getSubmenuTriggerProps: (\n    _props: ComponentPropsWithRef<'button'>,\n    _ref: React.Ref<HTMLButtonElement>,\n  ) => ComponentPropsWithRef<'button'>;\n};\n\nconst SubmenuContext = React.createContext<SubmenuContextType | undefined>(\n  undefined,\n);\n\nexport const useSubmenuContext = () => {\n  const context = React.useContext(SubmenuContext);\n  return context;\n};\n\nexport const SubmenuContextProvider = SubmenuContext.Provider;\n","import { css } from 'emotion';\nimport tokens from '@contentful/f36-tokens';\n\nexport const getMenuHeaderStyles = () => {\n  return css({\n    position: 'sticky',\n    top: 0,\n    left: 0,\n    backgroundColor: tokens.colorWhite,\n    borderBottom: `1px solid ${tokens.gray300}`,\n    marginBottom: tokens.spacing2Xs,\n    padding: `${tokens.spacing2Xs} 0`,\n    zIndex: 1001,\n  });\n};\n\nexport const getMenuFooterStyles = () => {\n  return css({\n    position: 'sticky',\n    bottom: 0,\n    left: 0,\n    backgroundColor: tokens.colorWhite,\n    borderTop: `1px solid ${tokens.gray300}`,\n    marginTop: tokens.spacing2Xs,\n    padding: `${tokens.spacing2Xs} 0`,\n    zIndex: 1001,\n  });\n};\n\nexport const getMenuListStyles = (props: {\n  hasStickyFooter?: boolean;\n  hasStickyHeader?: boolean;\n}) => ({\n  container: css({\n    // To get to our regular border radius for the inner menu items (6px),\n    // we need to use 8px on the outer container\n    borderRadius: '8px',\n    overflowY: 'auto',\n    position: 'relative',\n    padding: 0,\n    paddingTop: props.hasStickyHeader ? 0 : tokens.spacing2Xs,\n    paddingBottom: props.hasStickyFooter ? 0 : tokens.spacing2Xs,\n  }),\n});\n","import React from 'react';\nimport { cx } from 'emotion';\nimport type {\n  CommonProps,\n  PropsWithHTMLElement,\n  ExpandProps,\n} from '@contentful/f36-core';\n\nimport { getMenuHeaderStyles } from './MenuList.styles';\n\nexport type MenuListHeaderProps = PropsWithHTMLElement<CommonProps, 'div'>;\n\nexport const MenuListHeader: React.FC<ExpandProps<MenuListHeaderProps>> = (\n  props,\n) => {\n  const {\n    children,\n    testId = 'cf-ui-menu-list-header',\n    className,\n    ...otherProps\n  } = props;\n\n  const styles = getMenuHeaderStyles();\n\n  return (\n    <div\n      data-test-id={testId}\n      className={cx(styles, className)}\n      {...otherProps}\n    >\n      {children}\n    </div>\n  );\n};\n\nMenuListHeader.displayName = 'MenuListHeader';\n","import React from 'react';\nimport { cx } from 'emotion';\nimport type {\n  CommonProps,\n  PropsWithHTMLElement,\n  ExpandProps,\n} from '@contentful/f36-core';\n\nimport { getMenuFooterStyles } from './MenuList.styles';\n\nexport type MenuListFooterProps = PropsWithHTMLElement<CommonProps, 'div'>;\n\nexport const MenuListFooter: React.FC<ExpandProps<MenuListFooterProps>> = (\n  props,\n) => {\n  const {\n    children,\n    testId = 'cf-ui-menu-list-footer',\n    className,\n    ...otherProps\n  } = props;\n\n  const styles = getMenuFooterStyles();\n\n  return (\n    <div\n      data-test-id={testId}\n      className={cx(styles, className)}\n      {...otherProps}\n    >\n      {children}\n    </div>\n  );\n};\n\nMenuListFooter.displayName = 'MenuListFooter';\n","import React, { useEffect, useRef } from 'react';\nimport { cx } from 'emotion';\nimport {\n  mergeRefs,\n  useId,\n  type CommonProps,\n  type PolymorphicComponent,\n  type PolymorphicProps,\n  type ExpandProps,\n} from '@contentful/f36-core';\n\nimport { useMenuContext } from '../MenuContext';\nimport { getMenuItemStyles } from './MenuItem.styles';\n\nconst MENU_ITEM_DEFAULT_TAG = 'button';\n\ninterface MenuItemInternalProps extends CommonProps {\n  children?: React.ReactNode;\n  as?: 'a' | 'button';\n\n  /**\n   * Marks item as active\n   */\n  isActive?: boolean;\n  /**\n   * Marks item as disabled\n   */\n  isDisabled?: boolean;\n  /**\n   * Sets focus on item\n   */\n  isInitiallyFocused?: boolean;\n  /**\n   * Expects any of the icon components. Renders the icon aligned to the start\n   */\n  icon?: React.ReactElement;\n}\n\nexport type MenuItemProps<\n  E extends React.ElementType = typeof MENU_ITEM_DEFAULT_TAG,\n> = PolymorphicProps<MenuItemInternalProps, E>;\n\nfunction _MenuItem<E extends React.ElementType = typeof MENU_ITEM_DEFAULT_TAG>(\n  props: MenuItemProps<E>,\n  ref: React.Ref<any>,\n) {\n  const {\n    testId,\n    className,\n    as,\n    isActive = false,\n    isDisabled = false,\n    isInitiallyFocused,\n    icon,\n    ...otherProps\n  } = props;\n\n  const id = useId(undefined, 'menu-item');\n  const itemTestId = testId || `cf-ui-${id}`;\n  const styles = getMenuItemStyles({ isActive, isDisabled });\n\n  const { getMenuItemProps, focusMenuItem } = useMenuContext();\n\n  const itemRef = useRef<HTMLElement>(null);\n  useEffect(() => {\n    if (isInitiallyFocused && itemRef.current) {\n      focusMenuItem(itemRef.current);\n    }\n  }, [isInitiallyFocused, focusMenuItem]);\n\n  const Element = (as ?? MENU_ITEM_DEFAULT_TAG) as React.ElementType;\n\n  return (\n    <Element\n      role=\"menuitem\"\n      {...otherProps}\n      {...getMenuItemProps(otherProps)}\n      className={cx(styles.root, className)}\n      data-test-id={itemTestId}\n      ref={mergeRefs(itemRef, ref)}\n      tabIndex={-1}\n    >\n      {icon}\n      {props.children}\n    </Element>\n  );\n}\n\n_MenuItem.displayName = 'MenuItem';\n\nexport const MenuItem: PolymorphicComponent<\n  ExpandProps<MenuItemInternalProps>,\n  typeof MENU_ITEM_DEFAULT_TAG\n> = React.forwardRef(_MenuItem);\n","import { css, type ObjectInterpolation } from 'emotion';\nimport tokens from '@contentful/f36-tokens';\nimport type { MenuItemProps } from './MenuItem';\n\nconst activeStyle: ObjectInterpolation<undefined> = {\n  backgroundColor: tokens.gray200,\n  fontWeight: tokens.fontWeightMedium,\n  '&:hover': {\n    backgroundColor: tokens.gray200,\n  },\n};\n\nconst disabledStyle: ObjectInterpolation<undefined> = {\n  opacity: 0.5,\n  cursor: 'auto',\n  '&:hover': {\n    backgroundColor: 'unset',\n  },\n};\n\nexport const getMenuItemStyles = ({\n  isActive,\n  isDisabled,\n}: {\n  isActive: MenuItemProps['isActive'];\n  isDisabled: MenuItemProps['isDisabled'];\n}) => {\n  return {\n    root: css(\n      [\n        {\n          alignItems: 'center',\n          gap: tokens.spacingXs,\n          display: 'flex',\n          width: `calc(100% - 2 * ${tokens.spacing2Xs})`,\n          background: 'none',\n          border: 0,\n          borderRadius: tokens.borderRadiusMedium,\n          margin: `0 ${tokens.spacing2Xs}`,\n          outline: 'none',\n          fontSize: tokens.fontSizeM,\n          lineHeight: tokens.lineHeightM,\n          fontWeight: tokens.fontWeightNormal,\n          position: 'relative',\n          textAlign: 'left',\n          // Magic number to get a height of 32px on the item\n          padding: `6px ${tokens.spacingXs}`,\n          wordBreak: 'break-word',\n          whiteSpace: 'break-spaces',\n          cursor: 'pointer',\n          hyphens: 'auto',\n          minWidth: '150px',\n          textDecoration: 'none',\n          color: tokens.gray900,\n\n          '[role=\"menuitem\"] + &': {\n            marginTop: '2px',\n          },\n\n          '&:hover': {\n            backgroundColor: tokens.gray100,\n          },\n          '&:focus': {\n            boxShadow: `inset ${tokens.glowPrimary}`,\n          },\n          '&:focus:not(:focus-visible)': {\n            boxShadow: 'unset',\n          },\n          '&:focus-visible': {\n            boxShadow: `inset ${tokens.glowPrimary}`,\n          },\n          '&:active': {\n            backgroundColor: tokens.gray200,\n          },\n          '&:disabled': disabledStyle,\n        },\n      ],\n      isActive && activeStyle,\n      isDisabled && disabledStyle,\n    ),\n  };\n};\n","import React from 'react';\nimport { Popover } from '@contentful/f36-popover';\nimport { useMenuContext } from '../MenuContext';\nimport type { ExpandProps } from '@contentful/f36-core';\n\nexport interface MenuTriggerProps {\n  children: React.ReactNode;\n}\n\nexport const MenuTrigger = (props: ExpandProps<MenuTriggerProps>) => {\n  const child = React.Children.only(props.children) as any;\n  const { getTriggerProps } = useMenuContext();\n\n  return (\n    <Popover.Trigger>\n      {React.cloneElement(child, {\n        ...getTriggerProps(child.props, child.ref),\n        ['aria-haspopup']: 'menu',\n      })}\n    </Popover.Trigger>\n  );\n};\n","import React from 'react';\nimport type {\n  CommonProps,\n  PropsWithHTMLElement,\n  ExpandProps,\n} from '@contentful/f36-core';\nimport { cx } from 'emotion';\nimport { getMenuDividerStyles } from './MenuDivider.styles';\n\nexport type MenuDividerProps = PropsWithHTMLElement<CommonProps, 'hr'>;\n\nexport const MenuDivider = (props: ExpandProps<MenuDividerProps>) => {\n  const {\n    children,\n    testId = 'cf-ui-menu-divider',\n    className,\n    ...otherProps\n  } = props;\n\n  const styles = getMenuDividerStyles();\n\n  return (\n    <hr\n      aria-orientation=\"horizontal\"\n      data-test-id={testId}\n      className={cx(styles, className)}\n      {...otherProps}\n    />\n  );\n};\n","import { css } from 'emotion';\nimport tokens from '@contentful/f36-tokens';\n\nexport const getMenuDividerStyles = () =>\n  css({\n    border: 'none',\n    width: '100%',\n    height: '1px',\n    backgroundColor: tokens.gray200,\n    margin: `${tokens.spacing2Xs} 0`,\n  });\n","import React from 'react';\nimport { cx } from 'emotion';\nimport { Caption, type CaptionProps } from '@contentful/f36-typography';\nimport type { ExpandProps } from '@contentful/f36-core';\n\nimport { getMenuSectionTitleStyles } from './MenuSectionTitle.styles';\n\nexport type MenuSectionTitleProps = CaptionProps;\n\nexport const MenuSectionTitle = (props: ExpandProps<MenuSectionTitleProps>) => {\n  const {\n    children,\n    testId = 'cf-ui-menu-section-title',\n    className,\n    ...otherProps\n  } = props;\n\n  const styles = getMenuSectionTitleStyles();\n\n  return (\n    <Caption\n      // Techincally, menus cannot contain headings according to ARIA.\n      // We hide the heading from assistive technology, and only use it\n      // as a label\n      aria-hidden=\"true\"\n      as=\"div\"\n      testId={testId}\n      className={cx(styles, className)}\n      marginBottom=\"none\"\n      {...otherProps}\n    >\n      {children}\n    </Caption>\n  );\n};\n","import { css } from 'emotion';\nimport tokens from '@contentful/f36-tokens';\n\nexport const getMenuSectionTitleStyles = () =>\n  css({\n    color: tokens.gray500,\n    textAlign: 'left',\n    padding: `${tokens.spacingXs} ${tokens.spacingS} ${tokens.spacing2Xs}`,\n    lineHeight: tokens.lineHeightM,\n  });\n","import React, {\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from 'react';\nimport { Menu, MenuProps } from '../Menu';\nimport { useMenuContext } from '../MenuContext';\nimport { SubmenuContextProvider, SubmenuContextType } from '../SubmenuContext';\nimport { mergeRefs } from '@contentful/f36-core';\n\nconst SUBMENU_OFFSET: [number, number] = [-8, 2];\n\nexport type SubmenuProps = Omit<\n  MenuProps,\n  | 'placement'\n  | 'offset'\n  | 'usePortal'\n  | 'isOpen'\n  | 'isAutoalignmentEnabled'\n  | 'defaultIsOpen'\n>;\n\nexport const Submenu = (props: SubmenuProps) => {\n  const { onClose, onOpen, ...otherProps } = props;\n\n  const {\n    isOpen: isParentMenuOpen,\n    menuId,\n    propsToPropagateToSubmenus,\n  } = useMenuContext();\n\n  const triggerRef = useRef<HTMLButtonElement>(null);\n  const mouseLeaveTimerRef = useRef(null);\n\n  const [isOpen, setIsOpen] = useState(false);\n  const handleOpen = useCallback(() => {\n    setIsOpen(true);\n    window.clearTimeout(mouseLeaveTimerRef.current);\n\n    onOpen?.();\n  }, [onOpen]);\n  const handleClose = useCallback(() => {\n    setIsOpen(false);\n    window.clearTimeout(mouseLeaveTimerRef.current);\n\n    onClose?.();\n  }, [onClose]);\n  const closeAndFocusTrigger = useCallback(() => {\n    handleClose();\n    triggerRef.current?.focus({ preventScroll: true });\n  }, [handleClose]);\n\n  useEffect(() => {\n    // close when parent menu closed\n    if (isParentMenuOpen === false) {\n      setIsOpen(false);\n    }\n  }, [isParentMenuOpen]);\n\n  const contextValue: SubmenuContextType = useMemo(\n    () => ({\n      isOpen,\n      getSubmenuListProps: (_props) => ({\n        'data-parent-menu': menuId,\n        onMouseOver: (event) => {\n          handleOpen();\n\n          _props.onMouseOver?.(event);\n        },\n        onMouseLeave: (event) => {\n          closeAndFocusTrigger();\n\n          _props.onMouseLeave?.(event);\n        },\n      }),\n      getSubmenuTriggerProps: (_props, _ref) => ({\n        ref: mergeRefs(triggerRef, _ref),\n        onKeyDown: (event) => {\n          if (event.key === 'ArrowRight') {\n            event.preventDefault();\n            handleOpen();\n          }\n\n          _props.onKeyDown?.(event);\n        },\n        onMouseOver: (event) => {\n          handleOpen();\n\n          _props.onMouseOver?.(event);\n        },\n        onMouseLeave: (event) => {\n          mouseLeaveTimerRef.current = window.setTimeout(\n            closeAndFocusTrigger,\n            300,\n          );\n\n          _props.onMouseLeave?.(event);\n        },\n      }),\n    }),\n    [isOpen, menuId, handleOpen, closeAndFocusTrigger],\n  );\n\n  return (\n    <SubmenuContextProvider value={contextValue}>\n      <Menu\n        {...propsToPropagateToSubmenus}\n        {...otherProps}\n        isOpen={isOpen}\n        onClose={handleClose}\n        onOpen={handleOpen}\n        placement=\"right-start\"\n        offset={SUBMENU_OFFSET}\n        isAutoalignmentEnabled={false}\n      />\n    </SubmenuContextProvider>\n  );\n};\n","import React from 'react';\nimport { MenuTrigger } from '../MenuTrigger/MenuTrigger';\nimport { MenuItem, MenuItemProps } from '../MenuItem/MenuItem';\nimport { useSubmenuContext } from '../SubmenuContext';\nimport { ChevronRightIcon } from '@contentful/f36-icons';\nimport type { ExpandProps } from '@contentful/f36-core';\nimport { cx } from 'emotion';\nimport { getSubmenuTriggerStyles } from './SubmenuTrigger.styles';\n\nexport type SubmenuTriggerProps = Omit<\n  MenuItemProps<'button'>,\n  'isInitiallyFocused' | 'as'\n>;\n\nconst _SubmenuTrigger = (\n  props: ExpandProps<SubmenuTriggerProps>,\n  ref: React.Ref<HTMLButtonElement>,\n) => {\n  const { className, children } = props;\n  const { getSubmenuTriggerProps, isOpen } = useSubmenuContext();\n\n  const styles = getSubmenuTriggerStyles();\n\n  return (\n    <MenuTrigger>\n      <MenuItem\n        {...props}\n        {...getSubmenuTriggerProps(props, ref)}\n        className={cx(styles.root({ isActive: isOpen }), className)}\n      >\n        <span className={styles.content}>{children}</span>\n        <ChevronRightIcon className={styles.icon} />\n      </MenuItem>\n    </MenuTrigger>\n  );\n};\n\nexport const SubmenuTrigger = React.forwardRef(_SubmenuTrigger);\n","import { css } from 'emotion';\nimport tokens from '@contentful/f36-tokens';\n\nexport const getSubmenuTriggerStyles = () => {\n  return {\n    root: ({ isActive }) =>\n      css({\n        display: 'flex',\n        alignItems: 'center',\n        paddingRight: tokens.spacingXs,\n        ...(isActive\n          ? {\n              backgroundColor: tokens.gray100,\n            }\n          : {}),\n      }),\n    content: css({\n      marginRight: tokens.spacingM,\n    }),\n    icon: css({\n      marginLeft: 'auto',\n      fill: 'currentColor',\n    }),\n  };\n};\n","import { Menu as OriginalMenu } from './Menu';\nimport { MenuList } from './MenuList/MenuList';\nimport { MenuListHeader } from './MenuList/MenuListHeader';\nimport { MenuListFooter } from './MenuList/MenuListFooter';\nimport { MenuItem } from './MenuItem/MenuItem';\nimport { MenuTrigger } from './MenuTrigger/MenuTrigger';\nimport { MenuDivider } from './MenuDivider/MenuDivider';\nimport { MenuSectionTitle } from './MenuSectionTitle/MenuSectionTitle';\nimport { Submenu } from './Submenu/Submenu';\nimport { SubmenuTrigger } from './SubmenuTrigger/SubmenuTrigger';\n\ntype CompoundMenu = typeof OriginalMenu & {\n  List: typeof MenuList;\n  ListHeader: typeof MenuListHeader;\n  ListFooter: typeof MenuListFooter;\n  Item: typeof MenuItem;\n  Trigger: typeof MenuTrigger;\n  Divider: typeof MenuDivider;\n  SectionTitle: typeof MenuSectionTitle;\n  Submenu: typeof Submenu;\n  SubmenuTrigger: typeof SubmenuTrigger;\n};\n\nexport const Menu = OriginalMenu as CompoundMenu;\nMenu.List = MenuList;\nMenu.ListHeader = MenuListHeader;\nMenu.ListFooter = MenuListFooter;\nMenu.Item = MenuItem;\nMenu.Trigger = MenuTrigger;\nMenu.Divider = MenuDivider;\nMenu.SectionTitle = MenuSectionTitle;\nMenu.Submenu = Submenu;\nMenu.SubmenuTrigger = SubmenuTrigger;\n"],"mappings":""},"metadata":{},"sourceType":"module","externalDependencies":[]}