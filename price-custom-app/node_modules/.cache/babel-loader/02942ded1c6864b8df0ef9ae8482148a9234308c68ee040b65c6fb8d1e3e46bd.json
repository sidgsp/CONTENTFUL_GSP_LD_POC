{"ast":null,"code":"import a, { useState, useRef, useEffect } from 'react';\nimport { usePopper } from 'react-popper';\nimport { cx, css } from 'emotion';\nimport i from '@contentful/f36-tokens';\nimport { Portal } from '@contentful/f36-utils';\nimport { useId, Box } from '@contentful/f36-core';\nvar se = Object.defineProperty;\nvar d = Object.getOwnPropertySymbols;\nvar H = Object.prototype.hasOwnProperty,\n  K = Object.prototype.propertyIsEnumerable;\nvar L = (t, o, e) => o in t ? se(t, o, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: e\n  }) : t[o] = e,\n  y = (t, o) => {\n    for (var e in o || (o = {})) H.call(o, e) && L(t, e, o[e]);\n    if (d) for (var e of d(o)) K.call(o, e) && L(t, e, o[e]);\n    return t;\n  };\nvar V = (t, o) => {\n  var e = {};\n  for (var n in t) H.call(t, n) && o.indexOf(n) < 0 && (e[n] = t[n]);\n  if (t != null && d) for (var n of d(t)) o.indexOf(n) < 0 && K.call(t, n) && (e[n] = t[n]);\n  return e;\n};\nvar j = (t, o, e) => new Promise((n, u) => {\n  var h = s => {\n      try {\n        l(e.next(s));\n      } catch (p) {\n        u(p);\n      }\n    },\n    b = s => {\n      try {\n        l(e.throw(s));\n      } catch (p) {\n        u(p);\n      }\n    },\n    l = s => s.done ? n(s.value) : Promise.resolve(s.value).then(h, b);\n  l((e = e.apply(t, o)).next());\n});\nvar g = \"calc(-1 * ((1rem * (10 / \".concat(i.fontBaseDefault, \")) / 2))\"),\n  X = \"calc(1rem * (10 / \".concat(i.fontBaseDefault, \"))\");\nfunction q() {\n  return {\n    tooltipTargetWrapper: css({\n      display: \"inline-block\",\n      position: \"relative\"\n    }),\n    tooltip: css({\n      background: i.gray900,\n      fontFamily: i.fontStackPrimary,\n      fontSize: i.fontSizeS,\n      fontWeight: i.fontWeightNormal,\n      fontStyle: \"normal\",\n      textDecoration: \"none\",\n      color: i.colorWhite,\n      textAlign: \"center\",\n      lineHeight: i.lineHeightM,\n      padding: \"\".concat(i.spacingXs, \" calc(1rem * (10 / \").concat(i.fontBaseDefault, \"))\"),\n      borderRadius: i.borderRadiusMedium,\n      whiteSpace: \"normal\",\n      textTransform: \"initial\",\n      letterSpacing: \"initial\"\n    }),\n    tooltipHidden: css({\n      visibility: \"hidden\",\n      pointerEvents: \"none\",\n      zIndex: i.zIndexNegative\n    }),\n    tooltipContainer: css({\n      \"& > button[disabled]\": {\n        pointerEvents: \"none\"\n      }\n    }),\n    tooltipArrow: css({\n      position: \"absolute\",\n      '&[data-placement*=\"top\"]': {\n        bottom: 0,\n        left: 0,\n        marginBottom: g\n      },\n      '&[data-placement*=\"right\"]': {\n        left: 0,\n        marginLeft: g\n      },\n      '&[data-placement*=\"bottom\"]': {\n        left: 0,\n        top: 0,\n        marginTop: g\n      },\n      '&[data-placement*=\"left\"]': {\n        right: 0,\n        marginRight: g\n      },\n      \"&::before\": {\n        content: '\"\"',\n        display: \"block\",\n        height: X,\n        width: X,\n        backgroundColor: i.gray900,\n        transform: \"rotate3d(0, 0, 1, 45deg)\",\n        zIndex: i.zIndexNegative\n      }\n    })\n  };\n}\nvar ce = ue => {\n  var N = ue,\n    {\n      children: t,\n      className: o,\n      as: e = \"span\",\n      content: n,\n      label: u,\n      id: h,\n      isVisible: b = !1,\n      hideDelay: l = 0,\n      onBlur: s,\n      onFocus: p,\n      onMouseLeave: M,\n      onMouseOver: C,\n      onKeyDown: R,\n      showDelay: U = 0,\n      targetWrapperClassName: I,\n      maxWidth: E = 360,\n      testId: Y = \"cf-ui-tooltip\",\n      placement: Z = \"auto\",\n      usePortal: _ = !1,\n      isDisabled: ee = !1\n    } = N,\n    te = V(N, [\"children\", \"className\", \"as\", \"content\", \"label\", \"id\", \"isVisible\", \"hideDelay\", \"onBlur\", \"onFocus\", \"onMouseLeave\", \"onMouseOver\", \"onKeyDown\", \"showDelay\", \"targetWrapperClassName\", \"maxWidth\", \"testId\", \"placement\", \"usePortal\", \"isDisabled\"]);\n  let T = q(),\n    [oe, f] = useState(b),\n    z = useId(h, \"tooltip\"),\n    B = useRef(null),\n    W = useRef(null),\n    [ne, re] = useState(null),\n    {\n      styles: k,\n      attributes: x,\n      update: P\n    } = usePopper(B.current, W.current, {\n      placement: Z,\n      modifiers: [{\n        name: \"arrow\",\n        options: {\n          element: ne,\n          padding: parseFloat(i.borderRadiusSmall)\n        }\n      }, {\n        name: \"offset\",\n        options: {\n          offset: [0, 10]\n        }\n      }]\n    });\n  useEffect(() => {\n    (() => j(void 0, null, function* () {\n      P !== null && (yield P());\n    }))();\n  }, [n, P]);\n  let D = useRef(),\n    F = useRef(),\n    m = () => {\n      clearTimeout(D.current), clearTimeout(F.current);\n    };\n  useEffect(() => m, []);\n  let $ = () => {\n      m(), D.current = setTimeout(() => f(!0), U);\n    },\n    S = () => {\n      m(), F.current = setTimeout(() => f(!1), l);\n    },\n    ie = typeof E == \"string\" ? E : \"\".concat(E, \"px\"),\n    ae = y({\n      zIndex: i.zIndexTooltip,\n      maxWidth: ie\n    }, k.popper);\n  if (!n || ee) return a.createElement(Box, {\n    as: e,\n    className: I\n  }, t);\n  let A = a.createElement(Box, y({\n    as: \"span\",\n    id: z,\n    ref: W,\n    role: \"tooltip\",\n    style: ae,\n    className: cx(T.tooltip, o),\n    testId: Y,\n    onMouseEnter: () => {\n      m(), f(!0);\n    },\n    onMouseLeave: () => {\n      m(), f(!1);\n    }\n  }, x.popper), a.createElement(\"span\", {\n    \"aria-label\": u\n  }, n), a.createElement(\"span\", {\n    className: T.tooltipArrow,\n    \"data-placement\": x.popper && x.popper[\"data-popper-placement\"],\n    ref: re,\n    style: k.arrow\n  }));\n  return a.createElement(a.Fragment, null, oe ? a.createElement(a.Fragment, null, _ ? a.createElement(Portal, null, A) : A) : null, a.createElement(Box, y({\n    as: e,\n    ref: B,\n    className: cx(T.tooltipContainer, I),\n    onMouseEnter: r => {\n      $(), C && C(r);\n    },\n    onMouseLeave: r => {\n      S(), M && M(r);\n    },\n    onFocus: r => {\n      $(), p && p(r);\n    },\n    onBlur: r => {\n      S(), s && s(r);\n    },\n    onKeyDown: r => {\n      r.key === \"Escape\" && S(), R && R(r);\n    }\n  }, te), a.Children.map(t, r => {\n    if (a.isValidElement(r)) return a.cloneElement(r, {\n      \"aria-describedby\": z\n    });\n  })));\n};\nexport { ce as Tooltip };\n//# sourceMappingURL=out.js.map","map":{"version":3,"names":[],"sources":["C:\\Users\\Siddharth Ganti\\Desktop\\GSP_LD_POC\\price-custom-app\\node_modules\\@contentful\\f36-tooltip\\src\\Tooltip.tsx","C:\\Users\\Siddharth Ganti\\Desktop\\GSP_LD_POC\\price-custom-app\\node_modules\\@contentful\\f36-tooltip\\src\\Tooltip.styles.ts"],"sourcesContent":["import React, {\n  useEffect,\n  useState,\n  useRef,\n  type MouseEvent,\n  type FocusEvent,\n  type CSSProperties,\n  ReactElement,\n} from 'react';\nimport { usePopper } from 'react-popper';\nimport type { Placement } from '@popperjs/core';\nimport { cx } from 'emotion';\nimport type * as CSS from 'csstype';\nimport tokens from '@contentful/f36-tokens';\nimport { Portal } from '@contentful/f36-utils';\nimport { Box, useId, type CommonProps } from '@contentful/f36-core';\n\nimport { getStyles } from './Tooltip.styles';\n\nexport type TooltipPlacement = Placement;\n\nexport type WithEnhancedContent = {\n  /**\n   * Content of the tooltip\n   */\n  content?: ReactElement | string;\n  /**\n   * Accesible label property, only required when using ReactElement as content\n   */\n  label?: string;\n};\n\nexport type TooltipInternalProps = {\n  /**\n   * Child nodes to be rendered in the component and that will show the tooltip when they are hovered\n   */\n  children: React.ReactNode;\n  /**\n   * HTML element used to wrap the target of the tooltip\n   */\n  as?: React.ElementType;\n  /**\n   * A unique id of the tooltip\n   */\n  id?: string;\n  /**\n   * It controls the initial visibility of the tooltip\n   */\n  isVisible?: boolean;\n  /**\n   * It sets a max-width for the tooltip\n   */\n  maxWidth?: number | CSS.Property.MaxWidth;\n  /**\n   * Set a delay period in milliseconds before hiding the tooltip\n   */\n  hideDelay?: number;\n  /**\n   * Function that will be called when target gets blurred\n   */\n  onBlur?: (evt: FocusEvent) => void;\n  /**\n   * Function that will be called when target gets focused\n   */\n  onFocus?: (evt: FocusEvent) => void;\n  /**\n   * Function that will be called when the user move the mouse out of the target\n   */\n  onMouseLeave?: (evt: MouseEvent) => void;\n  /**\n   * Function that will be called when the user move the mouse over of the target\n   */\n  onMouseOver?: (evt: MouseEvent) => void;\n  /**\n   * Function that will be called when the user uses a keyboard key on the target\n   */\n  onKeyDown?: (evt: KeyboardEvent) => void;\n\n  /**\n   * It sets the \"preferred\" position of the tooltip\n   */\n  placement?: TooltipPlacement;\n  /**\n   * Set a delay period in milliseconds before showing the tooltip\n   */\n  showDelay?: number;\n  /**\n   * Class names to be appended to the className prop of the tooltipâ€™s target\n   */\n  targetWrapperClassName?: string;\n  /**\n   * Boolean to control whether or not to render the tooltip in a React Portal.\n   * Rendering content inside a Portal allows the tooltip to escape the bounds\n   * of its parent while still being positioned correctly. Using a Portal is\n   * necessary if an ancestor of the tooltip hides overflow.\n   *\n   * Defaults to `false`\n   */\n  usePortal?: boolean;\n  /**\n   * Prevents showing the tooltip\n   * @default false\n   */\n  isDisabled?: boolean;\n};\n\nexport interface TooltipProps\n  extends CommonProps,\n    TooltipInternalProps,\n    WithEnhancedContent {}\n\nexport const Tooltip = ({\n  children,\n  className,\n  as: HtmlTag = 'span',\n  content,\n  label,\n  id,\n  isVisible = false,\n  hideDelay = 0,\n  onBlur,\n  onFocus,\n  onMouseLeave,\n  onMouseOver,\n  onKeyDown,\n  showDelay = 0,\n  targetWrapperClassName,\n  maxWidth = 360,\n  testId = 'cf-ui-tooltip',\n  placement = 'auto',\n  usePortal = false,\n  isDisabled = false,\n  ...otherProps\n}: TooltipProps) => {\n  const styles = getStyles();\n  const [show, setShow] = useState(isVisible);\n  const tooltipId = useId(id, 'tooltip');\n  const elementRef = useRef(null);\n  const popperRef = useRef(null);\n  const [arrowRef, setArrowRef] = useState<HTMLSpanElement | null>(null);\n  const {\n    styles: popperStyles,\n    attributes,\n    update,\n  } = usePopper(elementRef.current, popperRef.current, {\n    placement: placement,\n    modifiers: [\n      {\n        name: 'arrow',\n        options: {\n          element: arrowRef,\n          padding: parseFloat(tokens.borderRadiusSmall),\n        },\n      },\n      {\n        name: 'offset',\n        options: {\n          offset: [0, 10],\n        },\n      },\n    ],\n  });\n\n  // necessary to update tooltip position in case the content is being updated\n  useEffect(() => {\n    const updatePosition = async () => {\n      if (update !== null) {\n        await update();\n      }\n    };\n    updatePosition();\n  }, [content, update]);\n\n  const showTimeoutRef = useRef<ReturnType<typeof setTimeout>>();\n  const hideTimeoutRef = useRef<ReturnType<typeof setTimeout>>();\n  const clearTimeouts = () => {\n    clearTimeout(showTimeoutRef.current);\n    clearTimeout(hideTimeoutRef.current);\n  };\n  useEffect(() => clearTimeouts, []);\n\n  const showPopover = () => {\n    clearTimeouts();\n    showTimeoutRef.current = setTimeout(() => setShow(true), showDelay);\n  };\n  const hidePopover = () => {\n    clearTimeouts();\n    hideTimeoutRef.current = setTimeout(() => setShow(false), hideDelay);\n  };\n\n  const contentMaxWidth =\n    typeof maxWidth === 'string' ? maxWidth : `${maxWidth}px`;\n\n  const contentStyles: CSSProperties = {\n    zIndex: tokens.zIndexTooltip,\n    maxWidth: contentMaxWidth,\n    ...popperStyles.popper,\n  };\n\n  if (!content || isDisabled) {\n    return (\n      <Box as={HtmlTag} className={targetWrapperClassName}>\n        {children}\n      </Box>\n    );\n  }\n\n  const tooltip = (\n    <Box\n      as=\"span\"\n      id={tooltipId}\n      ref={popperRef}\n      role=\"tooltip\"\n      style={contentStyles}\n      className={cx(styles.tooltip, className)}\n      testId={testId}\n      onMouseEnter={() => {\n        clearTimeouts();\n        setShow(true);\n      }}\n      onMouseLeave={() => {\n        clearTimeouts();\n        setShow(false);\n      }}\n      {...attributes.popper}\n    >\n      <span aria-label={label}>{content}</span>\n      <span\n        className={styles.tooltipArrow}\n        data-placement={\n          attributes.popper && attributes.popper['data-popper-placement']\n        }\n        ref={setArrowRef}\n        style={popperStyles.arrow}\n      />\n    </Box>\n  );\n\n  return (\n    <>\n      {show ? <>{usePortal ? <Portal>{tooltip}</Portal> : tooltip}</> : null}\n      <Box\n        as={HtmlTag}\n        ref={elementRef}\n        className={cx(styles.tooltipContainer, targetWrapperClassName)}\n        onMouseEnter={(evt: MouseEvent) => {\n          showPopover();\n          if (onMouseOver) onMouseOver(evt);\n        }}\n        onMouseLeave={(evt: MouseEvent) => {\n          hidePopover();\n          if (onMouseLeave) onMouseLeave(evt);\n        }}\n        onFocus={(evt: FocusEvent) => {\n          showPopover();\n          if (onFocus) onFocus(evt);\n        }}\n        onBlur={(evt: FocusEvent) => {\n          hidePopover();\n          if (onBlur) onBlur(evt);\n        }}\n        onKeyDown={(evt: KeyboardEvent) => {\n          if (evt.key === 'Escape') {\n            hidePopover();\n          }\n          if (onKeyDown) onKeyDown(evt);\n        }}\n        {...otherProps}\n      >\n        {React.Children.map<React.ReactNode, React.ReactNode>(\n          children,\n          (child) => {\n            if (React.isValidElement(child)) {\n              return React.cloneElement(child, {\n                'aria-describedby': tooltipId,\n              });\n            }\n          },\n        )}\n      </Box>\n    </>\n  );\n};\n","import { css } from 'emotion';\nimport tokens from '@contentful/f36-tokens';\n\nconst tooltipMargin = `calc(-1 * ((1rem * (10 / ${tokens.fontBaseDefault})) / 2))`;\nconst tooltipChevronSize = `calc(1rem * (10 / ${tokens.fontBaseDefault}))`;\n\nexport function getStyles() {\n  return {\n    tooltipTargetWrapper: css({\n      display: 'inline-block',\n      position: 'relative',\n    }),\n    tooltip: css({\n      background: tokens.gray900,\n      fontFamily: tokens.fontStackPrimary,\n      fontSize: tokens.fontSizeS,\n      fontWeight: tokens.fontWeightNormal,\n      fontStyle: 'normal',\n      textDecoration: 'none',\n      color: tokens.colorWhite,\n      textAlign: 'center',\n      lineHeight: tokens.lineHeightM,\n      padding: `${tokens.spacingXs} calc(1rem * (10 / ${tokens.fontBaseDefault}))`,\n      borderRadius: tokens.borderRadiusMedium,\n      whiteSpace: 'normal',\n      textTransform: 'initial',\n      letterSpacing: 'initial',\n    }),\n    tooltipHidden: css({\n      visibility: 'hidden',\n      pointerEvents: 'none',\n      zIndex: tokens.zIndexNegative,\n    }),\n    tooltipContainer: css({\n      '& > button[disabled]': { pointerEvents: 'none' },\n    }),\n    tooltipArrow: css({\n      position: 'absolute',\n      '&[data-placement*=\"top\"]': {\n        bottom: 0,\n        left: 0,\n        marginBottom: tooltipMargin,\n      },\n      '&[data-placement*=\"right\"]': {\n        left: 0,\n        marginLeft: tooltipMargin,\n      },\n      '&[data-placement*=\"bottom\"]': {\n        left: 0,\n        top: 0,\n        marginTop: tooltipMargin,\n      },\n      '&[data-placement*=\"left\"]': {\n        right: 0,\n        marginRight: tooltipMargin,\n      },\n      '&::before': {\n        content: '\"\"',\n        display: 'block',\n        height: tooltipChevronSize,\n        width: tooltipChevronSize,\n        backgroundColor: tokens.gray900,\n        transform: 'rotate3d(0, 0, 1, 45deg)',\n        zIndex: tokens.zIndexNegative,\n      },\n    }),\n  };\n}\n"],"mappings":""},"metadata":{},"sourceType":"module","externalDependencies":[]}